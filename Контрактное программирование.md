Пред-условия:

## Передаваемая сумма должна быть положительной.

## Константы:

Исходный банковский счет должен иметь положительный баланс.

## Пост-условия:

Баланс счета исходного банка должен быть равен начальному балансу, за вычетом суммы перевода.
Баланс целевого банковского счета должен быть равен начальному балансу плюс переведенная сумма.

Реализация «вручную»

## Легко реализовать пред- и пост-условия «вручную»:




#### Инварианты


Инварианты — это специальные условия, которые описывают целостное состояние объекта. Важной особенностью инвариантов является то, что они проверяются всегда после вызова любого публичного метода в классе и после вызова конструктора. Так как контракт определяет состояние объекта, а публичные методы — единственная возможность изменить состояние извне, то мы получаем полную спецификацию объекта.

```java
public void transfer(Account source, Account target, BigDecimal amount) {
    if (amount.compareTo(BigDecimal.ZERO) <= 0) {
        throw new IllegalArgument("Amount transferred must be higher than zero (" + amount + ")";
    }
    if (source.getBalance().compareTo(BigDecimal.ZERO) <= 0) {
        throw new IllegalArgument("Source account balance must be higher than zero (" + source.getBalance() + ")";
    }
    source.transfer(target, amount);
    if (source.getBalance().compareTo(BigDecimal.ZERO) <= 0) {
        throw new IllegalState("Source account balance must be higher than zero (" + source.getBalance() + ")";
    }
    // Other post-conditions...
}
```



Реализация на Java
```java
Возможно, вы уже работали с пред- и пост-условиями с помощью ключевого слова assert:

public void transfer(Account source, Account target, BigDecimal amount) {
    assert (amount.compareTo(BigDecimal.ZERO) <= 0);
    assert (source.getBalance().compareTo(BigDecimal.ZERO) <= 0);
    source.transfer(target, amount);
    assert (source.getBalance().compareTo(BigDecimal.ZERO) <= 0);
    // Other post-conditions...
}
```



## Что такое spring cloud contract

![image](https://user-images.githubusercontent.com/55126165/112777595-93357d00-907d-11eb-931b-b1732d5667c4.png)

Это файл, в котором на yaml или groovyDSL диалекте описано, как должны выглядеть запрос и ответ. По умолчанию все контракты лежат в папке /src/test/resources/contracts/*.
Для примера протестируем простейший GET-endpoint

```java
@GetMapping("/bets/{userId}")
public ResponseEntity<List<Bet>> getBets(@PathVariable("userId") String userId) {
   List<Bet> bets = service.getByUserId(userId);
   if (bets.isEmpty()) {
       return ResponseEntity.noContent().build();
   }
   return ResponseEntity.ok(bets);
}
```

Опишем контракт
```java
org.springframework.cloud.contract.spec.Contract.make {
   request {
       method 'GET'
       urlPath '/bets/2'
   }
   response {
       status 200
       headers {
           header('Content-Type', 'application/json')
       }
       body('''
         {
           "sport":"football",
           "amount": 1
         }
         '''
       )
   }
}
```

Unit тесты
```java
public class UserControllerTest extends ContractBae {

  @Test
  public void validate_get_200() throws Exception {
     // given:
        MockMvcRequestSpecification request = given();

     // when:
        ResponseOptions response = given().spec(request)
              .get("/bets/2");

     // then:
        assertThat(response.statusCode()).isEqualTo(200);
        assertThat(response.header("Content-Type")).isEqualTo("application/json");
     // and:
        DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
        assertThatJson(parsedJson).field("['amount']").isEqualTo(1);
        assertThatJson(parsedJson).field("['sport']").isEqualTo("football");
  }
}
```

Получается, что у нас есть один источник API контракта, который описан на человекопонятном языке, и из него мы генерируем юнит-тесты (теоретически еще и документацию), и из него же моки. Данный подход снижает риски ошибок интеграции между веб-приложениями.


#### Заключение


Контрактное программирование — абсолютно новая парадигма, которая может использоваться для защитного программирования, для улучшения качества кода и обеспечения читаемости контрактов, определяемых в виде требований и спецификаций. Большой плюс данной реализации в том, что код классов остается читаемым, сами аннотации читаются как документация, а также то, что в боевом режиме проверка может быть полностью отключена и не требует абсолютно никакого времени на дополнительные ненужные проверки в коде. Интересный факт: сам фреймоврк содержит лишь пару аннотаций и один класс аспекта, который связывает эти аннотации с конкретной логикой.

# Источники
Контрактное программирование Spring Java - https://habr.com/ru/post/424057/ 
Программирование согласно контракту на JVM - https://habr.com/ru/post/352672/

