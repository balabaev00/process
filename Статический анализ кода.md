# Статический анализ кода



​	**Статический анализ кода**— анализ программного обеспечения, производимый (в отличие от динамического анализа) без реального выполнения исследуемых программ. В большинстве случаев анализ производится над какой-либо версией исходного кода, хотя иногда анализу подвергается какой-нибудь вид объектного кода, например P-код или код на MSIL. Термин обычно применяют к анализу, производимому специальным программным обеспечением (ПО), тогда как ручной анализ называют «program understanding», «program comprehension» (*пониманием* или *постижением* программы).

​	В зависимости от используемого инструмента глубина анализа может варьироваться от определения поведения отдельных операторов до анализа, включающего весь имеющийся исходный код. Способы использования полученной в ходе анализа информации также различны — от выявления мест, возможно содержащих ошибки (утилиты типа Lint), до формальных методов, позволяющих математически доказать какие-либо свойства программы (например, соответствие поведения спецификации).

#### Типы ошибок, обнаруживаемых статическими анализаторами

- Неопределённое поведение — неинициализированные переменные, обращение к NULL-указателям. О простейших случаях сигнализируют и компиляторы.
- Нарушение алгоритма пользования библиотекой. Например, для каждого `fopen` нужен `fclose`. И если файловая переменная теряется раньше, чем файл закрывается, анализатор может сообщить об ошибке.
- Типичные сценарии, приводящие к недокументированному поведению. Стандартная библиотека языка Си известна большим количеством неудачных технических решений. Некоторые функции, например, `gets`, в принципе небезопасны. `sprintf` и `strcpy` безопасны лишь при определённых условиях.
- Переполнение буфера — когда компьютерная программа записывает данные за пределами выделенного в памяти буфера.

- Типичные сценарии, мешающие кроссплатформенности.
- Ошибки в повторяющемся коде. Многие программы исполняют несколько раз одно и то же с разными аргументами. Обычно повторяющиеся фрагменты не пишут с нуля, а размножают и исправляют.
- Ошибки форматных строк — в функциях наподобие `printf` могут быть ошибки с несоответствием форматной строки реальному типу параметров.
- Неизменный параметр, передаваемый в функцию — признак изменившихся требований к программе. Когда-то параметр был задействован, но сейчас он уже не нужен. В таком случае программист может вообще избавиться от этого параметра — и от связанной с ним логики.
- Утечки памяти и других ресурсов. Ради справедливости следует отметить, что в целом статические анализаторы проигрывают в сфере поиска утечек динамическим анализаторам кода.
- Прочие ошибки — многие функции из стандартных библиотек не имеют побочного эффекта, и вызов их как процедур не имеет смысла.



#### Анализаторы кода javascript

**JSLINT**

JSLint был первым статическим анализатором для JavaScript. Его можно запустить на официальном сайте или использовать одну из надстроек, которые можно запускать в локальных файлах. JSLint находит много важных ошибок, но он очень жесткий.Вот яркий пример:



```javascript
var s = 'mystring';
for (var i = 0; i < s.length; i++) {
 console.log(s.charAt(i));
}
```



JSLint показывает в этом коде две ошибки:



```
Unexpected '++'.
Move 'var' declarations to the top of the function.
```



Первая проблема – это определение переменной i в условиях цикла. JSLint также не принимает оператор ++ в конце определения цикла. Он хочет, чтобы код выглядел следующим образом:



```javascript
var s = 'mystring';
var i;
for (i = 0; i < s.length; i = i + 1) {
 console.log(s.charAt(i));
}
```



Я ценю создателей JSLint, но как по мне – это перебор. Он оказался жестким и для Антона Ковалева, поэтому он создал JSHint.

**JSHINT**

JSHint работает так же, как и JSLint, но он написан в дополнение к Node.js, а потому он более гибкий. JSHint включает большое количество опций, что позволяет выполнять пользовательские проверки путем написания своего собственного генератора отчетов.
Запустить JSHint можно с [сайта](http://jshint.com/), но в большинстве случаев лучше установить JSHint в качестве локального [инструмента](http://jshint.com/install/) командной строки с помощью Node.js. Как только вы установите JSHint, его можно запустить в ваших файлах с помощью такой команды:



```
jshint test.js
```



JSHint также включает плагины для популярных текстовых редакторов, поэтому его можно запускать в процессе написания кода.

JSHint можно настраивать под свои оптимальные настройки:

```javascript
 {     "camelcase" : true, // Названия переменных в camelCase стиле
       "undef" : true, // Все не глобальные переменные должны быть объявлены до их использования.
      "quotmark" : true, // Согласованность стиля кавычек
       "maxlen" : 120, // Максимальная длина строки
      "trailing" : true, // Запрещены пробелы на концах.
      "curly" : true, // Фигурные кавычки обязательны для каждого нового блока или области.
      "strict" : true, // Обязательно строгое использование.
      "browser" : true, // Стандартный браузер `window`, `document`.
      "devel" : true, // Разрешена панель разработчика `console.log();`.
      "jquery" : true, // Опция определяет глобальные переменные, предоставляемые библиотекой jQuery.
      "esversion" : 8, // Включить функции, представленные в ECMAScript 8.
       "node" : true // Определяет доступные глобальные переменные.
  }  
```



Предупреждения обозначаются желтым треугольником, а критические ошибки - красным кружком с крестиком. Наличие критических ошибок в коде, делает его совершенно не рабочим. Именно на такие ошибки нужно всегда в первую очередь обращать внимание.

![example](C:\Users\crash\OneDrive\Рабочий стол\Домашка\6_term\Theory of computational processes\ProcessCalculus\lab 3\example.png)

Источники:

[wiki]: https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7_%D0%BA%D0%BE%D0%B4%D0%B0
[habr]: https://habr.com/ru/company/paysto/blog/251277/
[8d9]: https://8d9.ru/program/jshint

